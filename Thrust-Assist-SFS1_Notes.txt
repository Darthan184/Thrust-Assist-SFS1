Thrust Assist Mod Notes

DONE: Setup Git Hub Repository
DONE: setup dark theme for Scite
DONE: VS Create using mod creation notes
    https://jmnet.one/sfs/forum/index.php?threads/mod-creation-getting-started.8880/
DONE: add full path to all clas names and remove all "using" statements
    - code now editable using Scite

FAIL: setup cli build
    C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild.exe
    https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-command-line-reference?view=vs-2022

    does not work msbuild cersion incpmpatibility

DONE: initial build (using visual studio)
DONE: initial test
    window is movable and position is stored and retreived from settings

SKIP: identify method to patch
    SFS.World.Rocket
        contains SFS.World.Throttle thottle;

    SFS.World.Throttle
        contains void UpdateThrottle()

DONE: attempt using Info Overload method to get rocket info
    can also be used to set thrust

DONE: attempt to get values needed for calc

DONE: perform calculation
    S = v * t

    S^2 = v^2 * t^2
    S = 0.5*a*t^2

    S = -2*v^2/a
    a = -2*v^2/S
    v=sqrt(-aS/2)

    throttle*ascentAcceleration+gravity=target
    throttle*ascentAcceleration=target-gravity
    throttle=(target-gravity)/ascentAcceleration

    slider does not work, have created  _UpDownValueLog class to omnlemenr an equivalent
    add 'Time' display then UI ready

DONE: test
    DONE: Moon
        DONE: surface to 100m hover, min throttle 50%
        DONE: 100m hover to surface, min throttle 1%
        DONE: 100m hover to surface, min throttle 50%
        DONE: min throttle 100%
        DONE: orbit to 40m hover  min throttle 79%
            - engines dont start in orbit
                - state as limitation?
            - sub- orbit time estimate is too high
                - now only have time estimate when engines are on
                - removed time display
            - on descent, stutters - seems OK
            - initial dV=3118.2 , orbit vel=339.8 , dV landed = 2625.6, used =  492.6
        DONE: orbit to land min throttle 100%
            - engine might not start if 1m is targeted from initial sub-orbit - sugg target 40m (the default) instead, dV landed = 2663.3 used =454.9

    DONE: test on Mercury
        orbit v=619.4, need to set 10 deg above retrograde
        dV on surface=2291.7  used=826.5 (excess 207.1)

        works, also hover manouver to mountain top

DONE: release build
NOTE: issues
    landing V should be set by adjusting throttle (not stopping and starting them) sugg detect if vel will be too low on next check and adjust thrust to make it hit targe vel on next check
    orbital needs a target position - use to determine distance whch can detering tgangental thrust
    add orbit centifgate force to as well as gravity
        a = (v^2)/r
    version s/b 0.2 ? (1.0 for a feature complete release) sugg landing at a target location is workin

DONE: landing V set by adjusting throttle
    DONE: code
    DONE: build
    DONE: test

DONE: re work calculations, base on target velocity
    DONE: code
    DONE: build
    DONE: test

NOTE: from testing I suspect there was an error in the original equations:
    S = 0.5 * v * t

    S^2 = 0.25 v^2 * t^2
    S = 0.5*a*t^2

    S = -0.5*v^2/a
    a = -0.5*v^2/S
    v=sqrt(-a*S*2)

DONE: try using min thrust in the target velocity calcs

FAIL: try a more accurate 'hight of spacecraft bottom' calc
    SFS.Parts.Modules.PolygonCollider has BoxCollider2D .collider_Box
    UnityEngine.Collider2D has UnityEngine.ColliderDistance2D .Distance(Collider2D)
    UnityEngine.ColliderDistance2D has .distance
    can't find a Collider2D to compare to

    SFS.Parts.Part_Utility has  bool .GetFramingBounds_WorldSpace(out Rect bounds, Part[] parts)
    SFS.World.Rocket has Part[] .partHolder.GetArray()
    can't find a way to use the bounds
    - test with spacecraft with low COM?

DONE: use 0 as minimum height
    DONE: code
    DONE: test

DONE: try using thrust vectors to calculate available thrust
    - test with spacecraft with angled thrusters?

DONE: more extensive testing
DONE: maybe use thrustNormal to add engines pointing diferrent directions?

DONE: release
    https://github.com/Darthan184/Thrust-Assist-SFS1/releases/download/0.5/ThrustAssistMod.dll
    https://github.com/Darthan184/Thrust-Assist-SFS1/releases

    DONE: create documentaion
    DONE: create release
    DONE: make public
    DONE: post

>>>: add support for horizontal velocity (branch: horz_vel_support)
    DONE: position marker control
        - need surface position control that specifies angle

        DONE: design & plan
            "<<<" ">>>" buttons
                +/- 1/10 circle or
                +/- Landmark/ landed spacecraft
            "<<" ">>" buttons 50m?
            "<" ">" buttons 5m?
            on/off button
            angle display

        DONE: 1/10 circle

    FAIL: display marker
        DONE: design & plan
            on world scene
                from InfoOverload\Functions.cs
                    var launchPadPos = Base.planetLoader.spaceCenter.LaunchPadLocation.position;
                    var fp32_launchPadPos = WorldView.ToLocalPosition(launchPadPos);

                    List<Vector3> points = new List<Vector3>()
                    {
                        new Vector3(fp32_launchPadPos.x - 30f, fp32_launchPadPos.y - 200f), // Lower-left corner
                        new Vector3(fp32_launchPadPos.x + 30f, fp32_launchPadPos.y - 200f), // Lower-right corner
                        new Vector3(fp32_launchPadPos.x + 30f, fp32_launchPadPos.y + 200f), // Upper-right corner
                        new Vector3(fp32_launchPadPos.x - 30f, fp32_launchPadPos.y + 200f) // Upper-left corner
                    };

                    Color c = function.GetSetting<Color>("Despawn Hitbox Color");

                    GLDrawer.DrawLine(points[0], points[1], c, 0.0025f * WorldView.main.viewDistance);
                    GLDrawer.DrawLine(points[1], points[2], c, 0.0025f * WorldView.main.viewDistance);
                    GLDrawer.DrawLine(points[2], points[3], c, 0.0025f * WorldView.main.viewDistance);
                    GLDrawer.DrawLine(points[3], points[0], c, 0.0025f * WorldView.main.viewDistance);
                    ----------------------------------------------
                    Double2 launchPadPos = SFS.Base.planetLoader.spaceCenter.LaunchPadLocation.position;
                    UnityEngine.Vector2 fp32_launchPadPos = SFS.World.WorldView.ToLocalPosition(launchPadPos);

                    SFS.WorldBase.PlanetLoader SFS.Base.planetLoader
                    SFS.World.SpaceCenterData SFS.Base.planetLoader.spaceCenter
                    SFS.World.Location SFS.Base.planetLoader.spaceCenter.LaunchPadLocation
                        => new Location(this.address.GetPlanet(), this.position_LaunchPad.GetPosition(this.Planet.Radius, this.angle));

                    SFS.World.SpaceCenterData.BuildingPosition this.position_LaunchPad
                    SFS.World.SpaceCenterData.BuildingPosition.GetPosition
                        {
                            return Double2.CosSin(0.01745329238474369 * originAngle - this.horizontalPosition / planetRadius, planetRadius + this.height);
                        }

                    0.01745329238474369 = radians per degree
                    Double2 CosSin(double angleRadians, double radius)
                    - ### canmot get this one to work

            on map scene
                SFS.World.Maps.Map.dashedLine.DrawLine(Vector3[] points, Planet planet, Color startColor, Color endColor)
                    points are SFS.World.Location.position values in km (*0.001)
                    - ### canmot get this one to work either!

        FAIL: code & test

    DONE: investigate how aerotrajectory writes to the map scene
        uses a complex-looking harmony patch (AeroTrajectory\Patches.cs) to patch
            SFS.World.Maps.MapManager.DrawMap()
            seems to insert new (call?)code after a DrawTrajectories() call

        starts at SFS.World.Location player.location.Value.position.ToVector2/1000.0
            seems to have planet as origin
            uses  SFS.World.Maps.Map.dashedLine.DrawLine

    DONE: display marker (2)
        DONE:Code
            DONE: Updater.cs
                - move map display code to Displayer.cs

            DONE: Displayer.cs
                ThrustAssistMod.Displayer.MapDrawMarker

            DONE: Patcher

        DONE: build
        DONE: test
            - AeroTrajectory OK
            - displays  on map
            - start at 90, reverse direction

    DONE: position marker control (2)
        - landmarks/landed spacecraft
            SFS.WorldBase.Planet.Landmark[].data.angle
            List<Rocket> SFS.World.GameManager.main.rockets

            rocket.location.planet   identifies planet
            rocket.location.velocity.magnitude = 0 indicates landed?
        DONE:Code
        DONE: build
        DONE: test

    DONE: calcs for horizontal velocity (1)
        DONE: code

    >>>: vector display
        investigate ANAIS
        C:\Dloads\SpaceFlightSim\ANAIS-main\SFS_Patches\VelocityArrowDrawer_Patch.cs
        patches:
            [HarmonyPatch(typeof(VelocityArrowDrawer), "OnLocationChange")]
            class
                [HarmonyPrefix]
                public static bool OnLocationChange_Prefix(Location _, Location location)

            [HarmonyPatch(typeof(VelocityArrowDrawer), "Start")]
            class
                [HarmonyPostfix]
                public static void Start_postfix()

            don't think I can do this without copying chunks of (unlicenced) code

    TBD: calcs for horizontal velocity (2)
        TBD: test

DONE: bug fixes 0.5.1
    DONE:  will work without capsule or probe.
        DONE: investigate
            test is: SFS.World.PlayerController.main.HasControl(SFS.UI.MsgDrawer.main)
                or Rocket.hasControl

        DONE: code
        DONE: test

    DONE: if left on, switch to build screen and launch, new rocket unexpectely launches
        DONE: investigate
            set _assistOn to false when GUIInactive() called (is on scene change)
        DONE: code
        DONE: test
            OK after switch to build screen
            stays on if revert to launch - fixed
            stays on if quicksave loaded - to be tested

    DONE: release:
    https://github.com/Darthan184/Thrust-Assist-SFS1/releases/download/0.5/ThrustAssistMod.dll
        https://github.com/Darthan184/Thrust-Assist-SFS1/releases

        DONE: create documentaion
        DONE: create release
        DONE: post
            amend first post
                - link and some text changes
            add reply

                0.5.1 Bug fixes.
                Uncontrollable rockets will no longer be affected
                Will no longer remain on after returning to the build screen, revert to launch or load quick save.

DONE: bug fixes 0.5.2
    - first launch after program start displays no rocket
    UI.set_AssistOn null reference exception
    DONE: develop
        DONE: code
        DONE: test

    DONE: release:
        DONE: release build
        DONE: commit
        DONE: create release in git hub
        DONE: post
            amend first post
               - link
                https://github.com/Darthan184/Thrust-Assist-SFS1/releases/download/0.5.2/ThrustAssistMod.dll

            add reply
                0.5.2 Bug fix.
                fix: first launch after program start displays no rocket
                (regression caused by 0.5.1)

NOTE: new features?
    - if switch between rockets, uncontrolled one keeps engine on but does not control it
        - store data per rocket (indexed by rocket object (weak) reference)?
        - would need SAS to work this way also

TBD: support for starting from orbit?

TBD: when release path is known can uncomment auto update data
    - current expected path https://github.com/Darthan184/Thrust-Assist-SFS1/releases/latest/download/ThrustAssistMod.dll
